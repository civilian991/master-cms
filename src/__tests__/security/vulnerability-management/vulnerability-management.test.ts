import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { VulnerabilityManagementService } from '../../../lib/security/vulnerability-management/vulnerability-service';
import { ComplianceMonitoringService } from '../../../lib/security/vulnerability-management/compliance-service';

// Mock dependencies
jest.mock('../../../lib/prisma', () => ({
  prisma: {
    vulnerabilityScan: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
    },
    vulnerabilityFinding: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
      groupBy: jest.fn(),
    },
    vulnerabilityRemediation: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
    },
    patchDeployment: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
    },
    complianceAssessment: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
      findUnique: jest.fn(),
    },
    complianceRequirement: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
    },
    complianceFinding: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
    },
    complianceEvidence: {
      create: jest.fn(),
      update: jest.fn(),
      findMany: jest.fn(),
    },
  },
}));

jest.mock('../../../lib/redis', () => ({
  redis: {
    setex: jest.fn(),
    get: jest.fn(),
    del: jest.fn(),
  },
}));

jest.mock('../../../lib/security/monitoring/siem-service', () => ({
  siemService: {
    ingestEvent: jest.fn(),
    on: jest.fn(),
    emit: jest.fn(),
  },
}));

jest.mock('../../../lib/security/incident-response/incident-service', () => ({
  incidentResponseService: {
    createIncident: jest.fn(),
  },
}));

import { prisma } from '../../../lib/prisma';
import { siemService } from '../../../lib/security/monitoring/siem-service';

describe('Vulnerability Management System', () => {
  let vulnerabilityService: VulnerabilityManagementService;
  let complianceService: ComplianceMonitoringService;

  const mockSiteId = 'site-123';
  const mockUserId = 'user-123';
  const mockScanId = 'SCAN-NET-123456';
  const mockVulnId = 'vuln-123';

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Create service instances
    vulnerabilityService = new VulnerabilityManagementService();
    complianceService = new ComplianceMonitoringService();
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('Vulnerability Scanning', () => {
    describe('Scan Scheduling', () => {
      it('should schedule network vulnerability scan successfully', async () => {
        // Mock database creation
        (prisma.vulnerabilityScan.create as jest.Mock).mockResolvedValue({
          id: mockScanId,
          scanType: 'NETWORK',
          target: '192.168.1.0/24',
          scope: ['192.168.1.1', '192.168.1.2'],
          status: 'SCHEDULED',
          priority: 'HIGH',
          scheduledTime: new Date(Date.now() + 60 * 60 * 1000), // 1 hour from now
          scanEngine: 'nmap',
          siteId: mockSiteId,
          vulnerabilitiesFound: 0,
          criticalCount: 0,
          highCount: 0,
          mediumCount: 0,
          lowCount: 0,
          infoCount: 0,
          compliance: ['PCI_DSS'],
          metadata: { scanConfiguration: {} },
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        // Mock SIEM event ingestion
        (siemService.ingestEvent as jest.Mock).mockResolvedValue({
          id: 'event-123',
          eventType: 'SECURITY_OPERATION',
        });

        const scanData = {
          scanType: 'NETWORK' as const,
          target: '192.168.1.0/24',
          scope: ['192.168.1.1', '192.168.1.2'],
          scheduledTime: new Date(Date.now() + 60 * 60 * 1000),
          priority: 'HIGH' as const,
          compliance: ['PCI_DSS'],
          siteId: mockSiteId,
        };

        const result = await vulnerabilityService.scheduleVulnerabilityScan(scanData);

        expect(result.id).toBe(mockScanId);
        expect(result.scanType).toBe('NETWORK');
        expect(result.target).toBe('192.168.1.0/24');
        expect(result.status).toBe('SCHEDULED');
        expect(result.priority).toBe('HIGH');
        expect(result.compliance).toContain('PCI_DSS');
        expect(result.scanEngine).toBe('nmap');

        expect(prisma.vulnerabilityScan.create).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              scanType: 'NETWORK',
              target: '192.168.1.0/24',
              scope: ['192.168.1.1', '192.168.1.2'],
              priority: 'HIGH',
              siteId: mockSiteId,
            }),
          })
        );

        expect(siemService.ingestEvent).toHaveBeenCalledWith(
          expect.objectContaining({
            eventType: 'SECURITY_OPERATION',
            title: expect.stringContaining('Vulnerability Scan Scheduled'),
          })
        );
      });

      it('should schedule immediate web application scan', async () => {
        (prisma.vulnerabilityScan.create as jest.Mock).mockResolvedValue({
          id: 'SCAN-WEB-654321',
          scanType: 'WEB_APPLICATION',
          target: 'https://app.example.com',
          scope: ['https://app.example.com/api', 'https://app.example.com/admin'],
          status: 'RUNNING',
          priority: 'URGENT',
          scanEngine: 'owasp-zap',
          siteId: mockSiteId,
          vulnerabilitiesFound: 0,
          compliance: ['NIST_CSF'],
          metadata: {},
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        const scanData = {
          scanType: 'WEB_APPLICATION' as const,
          target: 'https://app.example.com',
          scope: ['https://app.example.com/api', 'https://app.example.com/admin'],
          priority: 'URGENT' as const,
          compliance: ['NIST_CSF'],
          siteId: mockSiteId,
        };

        const result = await vulnerabilityService.scheduleVulnerabilityScan(scanData);

        expect(result.scanType).toBe('WEB_APPLICATION');
        expect(result.status).toBe('RUNNING'); // Should start immediately
        expect(result.priority).toBe('URGENT');
        expect(result.scanEngine).toBe('owasp-zap');
        expect(result.compliance).toContain('NIST_CSF');
      });

      it('should validate scan data and handle errors', async () => {
        const invalidScanData = {
          scanType: 'INVALID_TYPE' as any,
          target: '', // Empty target
          scope: [],
          siteId: '',
        };

        await expect(vulnerabilityService.scheduleVulnerabilityScan(invalidScanData)).rejects.toThrow();
      });
    });

    describe('Scan Execution', () => {
      it('should execute scan and process results', async () => {
        const mockScan = {
          id: mockScanId,
          scanType: 'NETWORK',
          target: '192.168.1.0/24',
          scope: ['192.168.1.1'],
          status: 'SCHEDULED',
          scanEngine: 'nmap',
          siteId: mockSiteId,
          compliance: ['PCI_DSS'],
          vulnerabilitiesFound: 0,
          criticalCount: 0,
          highCount: 0,
          mediumCount: 0,
          lowCount: 0,
          infoCount: 0,
          results: [],
          metadata: {},
          createdAt: new Date(),
          updatedAt: new Date(),
        };

        // Mock scan execution
        vulnerabilityService['performScan'] = jest.fn().mockResolvedValue([
          {
            cve: 'CVE-2024-0001',
            title: 'Critical SQL Injection',
            description: 'SQL injection vulnerability in web application',
            severity: 'CRITICAL',
            cvssScore: 9.8,
            affectedAssets: ['192.168.1.1'],
            exploitAvailable: true,
            patchAvailable: true,
            references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-0001'],
          },
          {
            cve: 'CVE-2024-0002',
            title: 'Medium XSS Vulnerability',
            description: 'Cross-site scripting vulnerability',
            severity: 'MEDIUM',
            cvssScore: 6.1,
            affectedAssets: ['192.168.1.1'],
            exploitAvailable: false,
            patchAvailable: true,
            references: [],
          },
        ]);

        // Mock database updates
        vulnerabilityService['updateScanStatus'] = jest.fn().mockResolvedValue(undefined);
        vulnerabilityService['createVulnerabilityFinding'] = jest.fn().mockResolvedValue(undefined);
        vulnerabilityService['triggerAutomatedActions'] = jest.fn().mockResolvedValue(undefined);
        vulnerabilityService['generateScanReport'] = jest.fn().mockResolvedValue(undefined);
        vulnerabilityService['checkComplianceRequirements'] = jest.fn().mockResolvedValue(undefined);

        await vulnerabilityService.executeScan(mockScan as any);

        expect(mockScan.status).toBe('COMPLETED');
        expect(mockScan.vulnerabilitiesFound).toBe(2);
        expect(mockScan.criticalCount).toBe(1);
        expect(mockScan.mediumCount).toBe(1);
        expect(mockScan.endTime).toBeDefined();
        expect(mockScan.duration).toBeGreaterThan(0);

        expect(vulnerabilityService['updateScanStatus']).toHaveBeenCalledWith(
          mockScanId,
          'RUNNING',
          expect.objectContaining({
            startTime: expect.any(Date),
          })
        );

        expect(vulnerabilityService['updateScanStatus']).toHaveBeenCalledWith(
          mockScanId,
          'COMPLETED',
          expect.objectContaining({
            endTime: expect.any(Date),
            vulnerabilitiesFound: 2,
            criticalCount: 1,
            mediumCount: 1,
          })
        );

        expect(vulnerabilityService['createVulnerabilityFinding']).toHaveBeenCalledTimes(2);
        expect(vulnerabilityService['triggerAutomatedActions']).toHaveBeenCalledWith(
          expect.arrayContaining([
            expect.objectContaining({
              severity: 'CRITICAL',
            }),
          ])
        );
      });

      it('should handle scan execution failures', async () => {
        const mockScan = {
          id: mockScanId,
          status: 'SCHEDULED',
          metadata: {},
          createdAt: new Date(),
          updatedAt: new Date(),
        };

        // Mock scan failure
        vulnerabilityService['performScan'] = jest.fn().mockRejectedValue(new Error('Scan engine error'));
        vulnerabilityService['updateScanStatus'] = jest.fn().mockResolvedValue(undefined);

        await vulnerabilityService.executeScan(mockScan as any);

        expect(mockScan.status).toBe('FAILED');
        expect(mockScan.endTime).toBeDefined();
        expect(mockScan.metadata.error).toBe('Scan engine error');

        expect(vulnerabilityService['updateScanStatus']).toHaveBeenCalledWith(
          mockScanId,
          'FAILED',
          expect.objectContaining({
            endTime: expect.any(Date),
            error: 'Scan engine error',
          })
        );
      });
    });
  });

  describe('Vulnerability Management', () => {
    describe('Remediation Planning', () => {
      it('should create comprehensive remediation plan', async () => {
        // Mock vulnerability finding
        const mockVulnerability = {
          id: mockVulnId,
          title: 'Critical SQL Injection',
          severity: 'CRITICAL',
          cvssScore: 9.8,
          affectedAssets: ['web-server-01'],
          exploitAvailable: true,
          patchAvailable: true,
        };

        vulnerabilityService['getVulnerabilityFinding'] = jest.fn().mockResolvedValue(mockVulnerability);
        vulnerabilityService['generateRemediationSteps'] = jest.fn().mockResolvedValue([
          {
            step: 1,
            description: 'Apply security patch to web application',
            completed: false,
          },
          {
            step: 2,
            description: 'Test application functionality',
            completed: false,
          },
          {
            step: 3,
            description: 'Deploy to production',
            completed: false,
          },
        ]);
        vulnerabilityService['estimateRemediationEffort'] = jest.fn().mockResolvedValue({
          hours: 8,
          cost: 2000,
        });
        vulnerabilityService['calculateRiskReduction'] = jest.fn().mockReturnValue(90);
        vulnerabilityService['updateVulnerabilityStatus'] = jest.fn().mockResolvedValue(undefined);
        vulnerabilityService['sendRemediationAssignment'] = jest.fn().mockResolvedValue(undefined);

        // Mock database creation
        (prisma.vulnerabilityRemediation.create as jest.Mock).mockResolvedValue({
          id: 'remediation-123',
          vulnerabilityId: mockVulnId,
          strategy: 'PATCH',
          description: 'PATCH remediation for Critical SQL Injection',
          assignedTo: mockUserId,
          status: 'PLANNED',
          priority: 'P1',
          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // 1 day
          approvalRequired: true,
          approvals: [],
          testingRequired: true,
          rollbackPlan: 'Revert to previous application version',
          implementationSteps: [],
          estimatedEffort: 8,
          cost: 2000,
          riskReduction: 90,
          metadata: {},
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        const remediationData = {
          vulnerabilityId: mockVulnId,
          strategy: 'PATCH' as const,
          assignedTo: mockUserId,
          dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
          priority: 'P1' as const,
          approvalRequired: true,
          testingRequired: true,
          rollbackPlan: 'Revert to previous application version',
        };

        const result = await vulnerabilityService.createRemediationPlan(remediationData);

        expect(result.id).toBe('remediation-123');
        expect(result.strategy).toBe('PATCH');
        expect(result.assignedTo).toBe(mockUserId);
        expect(result.priority).toBe('P1');
        expect(result.status).toBe('PLANNED');
        expect(result.approvalRequired).toBe(true);
        expect(result.testingRequired).toBe(true);
        expect(result.estimatedEffort).toBe(8);
        expect(result.cost).toBe(2000);
        expect(result.riskReduction).toBe(90);

        expect(prisma.vulnerabilityRemediation.create).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              vulnerabilityId: mockVulnId,
              strategy: 'PATCH',
              assignedTo: mockUserId,
              status: 'PLANNED',
              priority: 'P1',
              approvalRequired: true,
              testingRequired: true,
            }),
          })
        );

        expect(vulnerabilityService['updateVulnerabilityStatus']).toHaveBeenCalledWith(
          mockVulnId,
          'IN_REMEDIATION'
        );

        expect(vulnerabilityService['sendRemediationAssignment']).toHaveBeenCalledWith(result);
      });

      it('should create mitigation strategy for high-risk vulnerabilities', async () => {
        const mockVulnerability = {
          id: 'vuln-456',
          title: 'High Risk Buffer Overflow',
          severity: 'HIGH',
          cvssScore: 8.5,
          patchAvailable: false,
        };

        vulnerabilityService['getVulnerabilityFinding'] = jest.fn().mockResolvedValue(mockVulnerability);
        vulnerabilityService['generateRemediationSteps'] = jest.fn().mockResolvedValue([
          {
            step: 1,
            description: 'Implement input validation controls',
            completed: false,
          },
          {
            step: 2,
            description: 'Deploy web application firewall rules',
            completed: false,
          },
        ]);
        vulnerabilityService['estimateRemediationEffort'] = jest.fn().mockResolvedValue({
          hours: 16,
          cost: 4000,
        });
        vulnerabilityService['calculateRiskReduction'] = jest.fn().mockReturnValue(70);
        vulnerabilityService['updateVulnerabilityStatus'] = jest.fn().mockResolvedValue(undefined);
        vulnerabilityService['sendRemediationAssignment'] = jest.fn().mockResolvedValue(undefined);

        (prisma.vulnerabilityRemediation.create as jest.Mock).mockResolvedValue({
          id: 'remediation-456',
          strategy: 'MITIGATION',
          estimatedEffort: 16,
          cost: 4000,
          riskReduction: 70,
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        const remediationData = {
          vulnerabilityId: 'vuln-456',
          strategy: 'MITIGATION' as const,
          assignedTo: 'security-team',
          dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
          priority: 'P2' as const,
          approvalRequired: false,
          testingRequired: true,
        };

        const result = await vulnerabilityService.createRemediationPlan(remediationData);

        expect(result.strategy).toBe('MITIGATION');
        expect(result.estimatedEffort).toBe(16);
        expect(result.cost).toBe(4000);
        expect(result.riskReduction).toBe(70);
      });

      it('should handle remediation plan creation errors', async () => {
        vulnerabilityService['getVulnerabilityFinding'] = jest.fn().mockResolvedValue(null);

        const invalidRemediationData = {
          vulnerabilityId: 'non-existent-vuln',
          strategy: 'PATCH' as const,
          assignedTo: mockUserId,
          dueDate: new Date(),
          priority: 'P1' as const,
        };

        await expect(vulnerabilityService.createRemediationPlan(invalidRemediationData))
          .rejects.toThrow('Vulnerability not found');
      });
    });

    describe('Patch Management', () => {
      it('should deploy patch with proper approvals', async () => {
        // Mock approval validation
        vulnerabilityService['validateApprovals'] = jest.fn().mockReturnValue(true);
        vulnerabilityService['schedulePatchDeployment'] = jest.fn().mockResolvedValue(undefined);

        // Mock database creation
        (prisma.patchDeployment.create as jest.Mock).mockResolvedValue({
          id: 'patch-deploy-123',
          patchId: 'PATCH-2024-001',
          title: 'Patch Deployment: PATCH-2024-001',
          description: 'Automated deployment of patch PATCH-2024-001',
          targetSystems: ['web-server-01', 'web-server-02'],
          deploymentPhases: [
            {
              phase: 'STAGING',
              status: 'PENDING',
              scheduledTime: new Date(Date.now() + 60 * 60 * 1000),
              successCount: 0,
              failureCount: 0,
              systems: ['web-server-01', 'web-server-02'],
            },
          ],
          approvals: [
            {
              approver: 'security-lead',
              approved: true,
              timestamp: new Date(),
              comments: 'Approved for staging deployment',
            },
          ],
          rollbackPlan: 'Automated rollback to previous version',
          testingCriteria: ['Functionality test', 'Performance test'],
          metadata: {},
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        const patchData = {
          patchId: 'PATCH-2024-001',
          targetSystems: ['web-server-01', 'web-server-02'],
          deploymentPhase: 'STAGING' as const,
          scheduledTime: new Date(Date.now() + 60 * 60 * 1000),
          approvals: [
            {
              approver: 'security-lead',
              approved: true,
              timestamp: new Date(),
              comments: 'Approved for staging deployment',
            },
          ],
          rollbackPlan: 'Automated rollback to previous version',
          testingCriteria: ['Functionality test', 'Performance test'],
        };

        const result = await vulnerabilityService.deployPatch(patchData);

        expect(result.id).toBe('patch-deploy-123');
        expect(result.patchId).toBe('PATCH-2024-001');
        expect(result.targetSystems).toContain('web-server-01');
        expect(result.targetSystems).toContain('web-server-02');
        expect(result.deploymentPhases[0].phase).toBe('STAGING');
        expect(result.deploymentPhases[0].status).toBe('PENDING');
        expect(result.approvals[0].approved).toBe(true);

        expect(vulnerabilityService['validateApprovals']).toHaveBeenCalledWith(patchData.approvals);
        expect(vulnerabilityService['schedulePatchDeployment']).toHaveBeenCalledWith(result);
      });

      it('should reject patch deployment with insufficient approvals', async () => {
        vulnerabilityService['validateApprovals'] = jest.fn().mockReturnValue(false);

        const patchData = {
          patchId: 'PATCH-2024-002',
          targetSystems: ['web-server-01'],
          deploymentPhase: 'PRODUCTION' as const,
          scheduledTime: new Date(),
          approvals: [], // No approvals
          rollbackPlan: 'Manual rollback',
          testingCriteria: ['Basic test'],
        };

        await expect(vulnerabilityService.deployPatch(patchData))
          .rejects.toThrow('Insufficient approvals for patch deployment');
      });
    });

    describe('Vulnerability Metrics', () => {
      it('should calculate comprehensive vulnerability metrics', async () => {
        const mockVulnerabilities = [
          { id: '1', severity: 'CRITICAL', status: 'NEW', createdAt: new Date('2024-01-01'), resolutionTime: null },
          { id: '2', severity: 'HIGH', status: 'RESOLVED', createdAt: new Date('2024-01-02'), resolutionTime: 48 },
          { id: '3', severity: 'MEDIUM', status: 'IN_REMEDIATION', createdAt: new Date('2024-01-03'), resolutionTime: null },
          { id: '4', severity: 'LOW', status: 'RESOLVED', createdAt: new Date('2024-01-04'), resolutionTime: 168 },
          { id: '5', severity: 'CRITICAL', status: 'RESOLVED', createdAt: new Date('2024-01-05'), resolutionTime: 24 },
        ];

        (prisma.vulnerabilityFinding.findMany as jest.Mock).mockResolvedValue(mockVulnerabilities);

        // Mock helper methods
        vulnerabilityService['groupBy'] = jest.fn().mockImplementation((items, field) => {
          if (field === 'severity') {
            return { CRITICAL: 2, HIGH: 1, MEDIUM: 1, LOW: 1 };
          }
          if (field === 'status') {
            return { NEW: 1, RESOLVED: 3, IN_REMEDIATION: 1 };
          }
          return {};
        });

        vulnerabilityService['calculateAgeDistribution'] = jest.fn().mockReturnValue({
          '0-7 days': 2,
          '8-30 days': 2,
          '31-90 days': 1,
          '90+ days': 0,
        });

        vulnerabilityService['calculateMTTR'] = jest.fn().mockReturnValue(80); // 80 hours average
        vulnerabilityService['calculateSLACompliance'] = jest.fn().mockReturnValue(75); // 75% compliance
        vulnerabilityService['calculateOverallRiskScore'] = jest.fn().mockReturnValue(6.5);
        vulnerabilityService['calculateVulnerabilityTrends'] = jest.fn().mockResolvedValue([
          { date: new Date('2024-01-01'), discovered: 5, remediated: 3, backlog: 2 },
          { date: new Date('2024-01-02'), discovered: 3, remediated: 4, backlog: 1 },
        ]);
        vulnerabilityService['checkComplianceFrameworks'] = jest.fn().mockResolvedValue({
          PCI_DSS: { compliant: false, score: 70, gaps: ['High vulnerabilities pending'] },
          NIST_CSF: { compliant: true, score: 85, gaps: [] },
        });

        const timeRange = {
          start: new Date('2024-01-01'),
          end: new Date('2024-01-31'),
        };

        const result = await vulnerabilityService.getVulnerabilityMetrics(mockSiteId, timeRange);

        expect(result.totalVulnerabilities).toBe(5);
        expect(result.bySeverity.CRITICAL).toBe(2);
        expect(result.bySeverity.HIGH).toBe(1);
        expect(result.byStatus.NEW).toBe(1);
        expect(result.byStatus.RESOLVED).toBe(3);
        expect(result.meanTimeToRemediation).toBe(80);
        expect(result.slaCompliance).toBe(75);
        expect(result.riskScore).toBe(6.5);
        expect(result.trendData).toHaveLength(2);
        expect(result.complianceStatus.PCI_DSS.compliant).toBe(false);
        expect(result.complianceStatus.NIST_CSF.compliant).toBe(true);
      });

      it('should filter vulnerabilities by criteria', async () => {
        const mockFilteredVulnerabilities = [
          { id: '1', severity: 'CRITICAL', status: 'NEW', assignedTo: mockUserId },
          { id: '2', severity: 'CRITICAL', status: 'IN_REMEDIATION', assignedTo: mockUserId },
        ];

        (prisma.vulnerabilityFinding.findMany as jest.Mock).mockResolvedValue(mockFilteredVulnerabilities);
        vulnerabilityService['mapPrismaFindingToFinding'] = jest.fn().mockImplementation(f => f);

        const filters = {
          severity: 'CRITICAL',
          assignedTo: mockUserId,
          siteId: mockSiteId,
          limit: 10,
        };

        const result = await vulnerabilityService.getVulnerabilityFindings(filters);

        expect(result).toHaveLength(2);
        expect(result[0].severity).toBe('CRITICAL');
        expect(result[0].assignedTo).toBe(mockUserId);

        expect(prisma.vulnerabilityFinding.findMany).toHaveBeenCalledWith(
          expect.objectContaining({
            where: expect.objectContaining({
              severity: 'CRITICAL',
              assignedTo: mockUserId,
              siteId: mockSiteId,
            }),
            take: 10,
          })
        );
      });
    });
  });

  describe('Compliance Monitoring', () => {
    describe('Compliance Assessment', () => {
      it('should create PCI DSS compliance assessment', async () => {
        // Mock database creation
        (prisma.complianceAssessment.create as jest.Mock).mockResolvedValue({
          id: 'assessment-123',
          framework: 'PCI_DSS',
          siteId: mockSiteId,
          assessmentType: 'SELF_ASSESSMENT',
          scope: ['network', 'web_applications'],
          assessor: mockUserId,
          status: 'PLANNED',
          startDate: new Date(),
          endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
          overallScore: 0,
          passingScore: 85,
          passed: false,
          requirements: [],
          findings: [],
          evidence: [],
          recommendations: [],
          metadata: {},
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        (prisma.complianceRequirement.create as jest.Mock).mockResolvedValue({
          id: 'req-123',
          assessmentId: 'assessment-123',
          requirementId: '11.2.1',
          title: 'Internal vulnerability scans',
          description: 'Perform internal vulnerability scans at least quarterly',
          category: 'VULNERABILITY_MANAGEMENT',
          priority: 'HIGH',
          status: 'NOT_ASSESSED',
          score: 0,
          maxScore: 3,
          evidence: [],
          findings: [],
          lastAssessed: expect.any(Date),
          nextAssessment: expect.any(Date),
          metadata: {},
        });

        complianceService['mapPrismaRequirementToRequirement'] = jest.fn().mockReturnValue({
          id: 'req-123',
          requirementId: '11.2.1',
          title: 'Internal vulnerability scans',
          category: 'VULNERABILITY_MANAGEMENT',
          priority: 'HIGH',
          status: 'NOT_ASSESSED',
          score: 0,
          maxScore: 3,
        });

        const assessmentData = {
          framework: 'PCI_DSS' as const,
          siteId: mockSiteId,
          assessmentType: 'SELF_ASSESSMENT' as const,
          scope: ['network', 'web_applications'],
          assessor: mockUserId,
          startDate: new Date(),
          endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
          requirements: ['11.2.1', '11.2.2'],
        };

        const result = await complianceService.createComplianceAssessment(assessmentData);

        expect(result.id).toBe('assessment-123');
        expect(result.framework).toBe('PCI_DSS');
        expect(result.assessmentType).toBe('SELF_ASSESSMENT');
        expect(result.scope).toContain('network');
        expect(result.scope).toContain('web_applications');
        expect(result.assessor).toBe(mockUserId);
        expect(result.status).toBe('PLANNED');
        expect(result.passingScore).toBe(85);

        expect(prisma.complianceAssessment.create).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              framework: 'PCI_DSS',
              assessmentType: 'SELF_ASSESSMENT',
              scope: ['network', 'web_applications'],
              assessor: mockUserId,
              passingScore: 85,
            }),
          })
        );

        expect(prisma.complianceRequirement.create).toHaveBeenCalled();
      });

      it('should conduct automated compliance assessment', async () => {
        const mockAssessment = {
          id: 'assessment-123',
          framework: 'PCI_DSS',
          siteId: mockSiteId,
          status: 'PLANNED',
          passingScore: 85,
          requirements: [
            {
              id: 'req-1',
              requirementId: '11.2.1',
              category: 'VULNERABILITY_MANAGEMENT',
              priority: 'HIGH',
              status: 'NOT_ASSESSED',
              score: 0,
              maxScore: 3,
              findings: [],
            },
            {
              id: 'req-2',
              requirementId: '6.2',
              category: 'PATCH_MANAGEMENT',
              priority: 'CRITICAL',
              status: 'NOT_ASSESSED',
              score: 0,
              maxScore: 4,
              findings: [],
            },
          ],
          findings: [],
          recommendations: [],
        };

        complianceService['activeAssessments'].set('assessment-123', mockAssessment as any);

        // Mock assessment methods
        complianceService['updateAssessmentStatus'] = jest.fn().mockResolvedValue(undefined);
        complianceService['assessRequirement'] = jest.fn().mockImplementation(async (assessment, requirement) => {
          if (requirement.category === 'VULNERABILITY_MANAGEMENT') {
            requirement.status = 'COMPLIANT';
            requirement.score = 3;
          } else if (requirement.category === 'PATCH_MANAGEMENT') {
            requirement.status = 'PARTIALLY_COMPLIANT';
            requirement.score = 2;
            requirement.findings.push('Some critical vulnerabilities remain unpatched');
          }
        });

        complianceService['generateFindings'] = jest.fn().mockResolvedValue([
          {
            id: 'finding-1',
            requirementId: '6.2',
            severity: 'HIGH',
            finding: 'Some critical vulnerabilities remain unpatched',
            status: 'OPEN',
          },
        ]);

        complianceService['generateRecommendations'] = jest.fn().mockResolvedValue([
          'Implement automated patch management',
          'Increase vulnerability scan frequency',
        ]);

        complianceService['updateAssessmentResults'] = jest.fn().mockResolvedValue(undefined);
        complianceService['generateComplianceReport'] = jest.fn().mockResolvedValue(undefined);

        const result = await complianceService.conductComplianceAssessment('assessment-123');

        expect(result.status).toBe('COMPLETED');
        expect(result.overallScore).toBeCloseTo(71.43, 1); // (3 + 2) / (3 + 4) * 100
        expect(result.passed).toBe(false); // Below 85% threshold
        expect(result.completedDate).toBeDefined();
        expect(result.findings).toHaveLength(1);
        expect(result.recommendations).toContain('Implement automated patch management');

        expect(complianceService['updateAssessmentStatus']).toHaveBeenCalledWith('assessment-123', 'IN_PROGRESS');
        expect(complianceService['assessRequirement']).toHaveBeenCalledTimes(2);
        expect(complianceService['generateFindings']).toHaveBeenCalledWith(mockAssessment);
        expect(complianceService['generateRecommendations']).toHaveBeenCalledWith(mockAssessment);
      });

      it('should handle assessment failures gracefully', async () => {
        const mockAssessment = {
          id: 'assessment-failed',
          status: 'PLANNED',
        };

        complianceService['activeAssessments'].set('assessment-failed', mockAssessment as any);
        complianceService['updateAssessmentStatus'] = jest.fn().mockResolvedValue(undefined);
        complianceService['assessRequirement'] = jest.fn().mockRejectedValue(new Error('Assessment error'));

        await expect(complianceService.conductComplianceAssessment('assessment-failed'))
          .rejects.toThrow('Assessment failed: Assessment error');

        expect(mockAssessment.status).toBe('FAILED');
        expect(complianceService['updateAssessmentStatus']).toHaveBeenCalledWith('assessment-failed', 'FAILED');
      });
    });

    describe('Compliance Evidence', () => {
      it('should add compliance evidence successfully', async () => {
        (prisma.complianceEvidence.create as jest.Mock).mockResolvedValue({
          id: 'evidence-123',
          assessmentId: 'assessment-123',
          requirementId: '11.2.1',
          evidenceType: 'SCAN_RESULT',
          fileName: 'vulnerability_scan_report.pdf',
          filePath: '/evidence/vulnerability_scan_report.pdf',
          description: 'Quarterly vulnerability scan report',
          collectedBy: mockUserId,
          collectedAt: new Date(),
          hash: 'sha256:abc123...',
          verified: false,
          metadata: {},
        });

        const evidenceData = {
          assessmentId: 'assessment-123',
          requirementId: '11.2.1',
          evidenceType: 'SCAN_RESULT' as const,
          fileName: 'vulnerability_scan_report.pdf',
          filePath: '/evidence/vulnerability_scan_report.pdf',
          description: 'Quarterly vulnerability scan report',
          collectedBy: mockUserId,
          hash: 'sha256:abc123...',
        };

        const result = await complianceService.addComplianceEvidence(evidenceData);

        expect(result.id).toBe('evidence-123');
        expect(result.evidenceType).toBe('SCAN_RESULT');
        expect(result.fileName).toBe('vulnerability_scan_report.pdf');
        expect(result.description).toBe('Quarterly vulnerability scan report');
        expect(result.collectedBy).toBe(mockUserId);
        expect(result.verified).toBe(false);

        expect(prisma.complianceEvidence.create).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              assessmentId: 'assessment-123',
              requirementId: '11.2.1',
              evidenceType: 'SCAN_RESULT',
              collectedBy: mockUserId,
            }),
          })
        );
      });
    });

    describe('Compliance Reporting', () => {
      it('should generate comprehensive compliance report', async () => {
        const mockAssessment = {
          id: 'assessment-123',
          framework: 'PCI_DSS',
          overallScore: 78,
          passed: false,
          requirements: [
            { id: '1', status: 'COMPLIANT' },
            { id: '2', status: 'NON_COMPLIANT' },
            { id: '3', status: 'COMPLIANT' },
          ],
          findings: [
            { id: '1', severity: 'CRITICAL' },
            { id: '2', severity: 'HIGH' },
            { id: '3', severity: 'HIGH' },
          ],
          recommendations: ['Improve patch management', 'Enhance monitoring'],
          completedDate: new Date(),
        };

        complianceService['getAssessments'] = jest.fn().mockResolvedValue([mockAssessment]);
        complianceService['calculateComplianceTrends'] = jest.fn().mockResolvedValue([
          { date: new Date('2024-01-01'), score: 75, compliantCount: 8, totalCount: 10 },
          { date: new Date('2024-02-01'), score: 78, compliantCount: 9, totalCount: 12 },
        ]);
        complianceService['generateExecutiveSummary'] = jest.fn().mockReturnValue('Executive summary text');
        complianceService['generateTechnicalDetails'] = jest.fn().mockReturnValue('Technical details text');
        complianceService['storeComplianceReport'] = jest.fn().mockResolvedValue(undefined);

        const reportData = {
          framework: 'PCI_DSS' as const,
          siteId: mockSiteId,
          reportType: 'DETAILED' as const,
          timeRange: {
            start: new Date('2024-01-01'),
            end: new Date('2024-03-31'),
          },
        };

        const result = await complianceService.generateComplianceReport(reportData);

        expect(result.framework).toBe('PCI_DSS');
        expect(result.reportType).toBe('DETAILED');
        expect(result.summary.overallScore).toBe(78);
        expect(result.summary.passed).toBe(false);
        expect(result.summary.totalRequirements).toBe(3);
        expect(result.summary.compliantRequirements).toBe(2);
        expect(result.summary.nonCompliantRequirements).toBe(1);
        expect(result.summary.criticalFindings).toBe(1);
        expect(result.summary.highFindings).toBe(2);
        expect(result.trends).toHaveLength(2);
        expect(result.recommendations).toContain('Improve patch management');
        expect(result.executiveSummary).toBe('Executive summary text');
        expect(result.technicalDetails).toBe('Technical details text');

        expect(complianceService['storeComplianceReport']).toHaveBeenCalledWith(result);
      });
    });

    describe('Compliance Metrics', () => {
      it('should calculate comprehensive compliance metrics', async () => {
        const mockLatestAssessment = {
          id: 'latest-assessment',
          overallScore: 82,
          passed: true,
          requirements: [
            { status: 'COMPLIANT' },
            { status: 'COMPLIANT' },
            { status: 'NON_COMPLIANT' },
            { status: 'COMPLIANT' },
          ],
          findings: [
            { severity: 'CRITICAL', status: 'OPEN' },
            { severity: 'HIGH', status: 'RESOLVED' },
          ],
          completedDate: new Date(),
          createdAt: new Date(),
        };

        const mockPreviousAssessment = {
          overallScore: 75,
        };

        complianceService['getLatestAssessment'] = jest.fn().mockResolvedValue(mockLatestAssessment);
        complianceService['getPreviousAssessment'] = jest.fn().mockResolvedValue(mockPreviousAssessment);
        complianceService['calculateVulnerabilityAlignment'] = jest.fn().mockResolvedValue({
          criticalVulnsCompliance: 85,
          highVulnsCompliance: 90,
          remediationSLAMet: 78,
        });
        complianceService['calculateRiskLevel'] = jest.fn().mockReturnValue('MEDIUM');
        complianceService['calculateNextAssessmentDate'] = jest.fn().mockReturnValue(
          new Date(Date.now() + 90 * 24 * 60 * 60 * 1000) // 90 days
        );

        const result = await complianceService.getComplianceMetrics('PCI_DSS', mockSiteId);

        expect(result.framework).toBe('PCI_DSS');
        expect(result.currentScore).toBe(82);
        expect(result.previousScore).toBe(75);
        expect(result.trend).toBe('IMPROVING');
        expect(result.complianceRate).toBe(75); // 3 out of 4 compliant
        expect(result.criticalGaps).toBe(1); // 1 critical finding open
        expect(result.vulnerabilityAlignment.criticalVulnsCompliance).toBe(85);
        expect(result.lastAssessment).toBeDefined();
        expect(result.nextAssessment).toBeDefined();
        expect(result.riskLevel).toBe('MEDIUM');
      });
    });
  });

  describe('Integration Tests', () => {
    it('should handle complete vulnerability management lifecycle', async () => {
      // 1. Schedule scan
      (prisma.vulnerabilityScan.create as jest.Mock).mockResolvedValue({
        id: mockScanId,
        scanType: 'NETWORK',
        status: 'SCHEDULED',
        siteId: mockSiteId,
        vulnerabilitiesFound: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        infoCount: 0,
        compliance: ['PCI_DSS'],
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const scan = await vulnerabilityService.scheduleVulnerabilityScan({
        scanType: 'NETWORK',
        target: '192.168.1.0/24',
        scope: ['192.168.1.1'],
        siteId: mockSiteId,
        compliance: ['PCI_DSS'],
      });

      expect(scan.id).toBe(mockScanId);

      // 2. Execute scan and find vulnerabilities
      const mockVulnerability = {
        id: mockVulnId,
        scanId: mockScanId,
        severity: 'CRITICAL',
        status: 'NEW',
        patchAvailable: true,
      };

      vulnerabilityService['performScan'] = jest.fn().mockResolvedValue([mockVulnerability]);
      vulnerabilityService['updateScanStatus'] = jest.fn().mockResolvedValue(undefined);
      vulnerabilityService['createVulnerabilityFinding'] = jest.fn().mockResolvedValue(undefined);
      vulnerabilityService['triggerAutomatedActions'] = jest.fn().mockResolvedValue(undefined);
      vulnerabilityService['generateScanReport'] = jest.fn().mockResolvedValue(undefined);
      vulnerabilityService['checkComplianceRequirements'] = jest.fn().mockResolvedValue(undefined);

      await vulnerabilityService.executeScan(scan as any);

      expect(scan.status).toBe('COMPLETED');

      // 3. Create remediation plan
      vulnerabilityService['getVulnerabilityFinding'] = jest.fn().mockResolvedValue(mockVulnerability);
      vulnerabilityService['generateRemediationSteps'] = jest.fn().mockResolvedValue([]);
      vulnerabilityService['estimateRemediationEffort'] = jest.fn().mockResolvedValue({ hours: 8, cost: 2000 });
      vulnerabilityService['calculateRiskReduction'] = jest.fn().mockReturnValue(90);
      vulnerabilityService['updateVulnerabilityStatus'] = jest.fn().mockResolvedValue(undefined);
      vulnerabilityService['sendRemediationAssignment'] = jest.fn().mockResolvedValue(undefined);

      (prisma.vulnerabilityRemediation.create as jest.Mock).mockResolvedValue({
        id: 'remediation-123',
        vulnerabilityId: mockVulnId,
        strategy: 'PATCH',
        status: 'PLANNED',
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const remediation = await vulnerabilityService.createRemediationPlan({
        vulnerabilityId: mockVulnId,
        strategy: 'PATCH',
        assignedTo: mockUserId,
        dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
        priority: 'P1',
      });

      expect(remediation.id).toBe('remediation-123');

      // 4. Create compliance assessment
      (prisma.complianceAssessment.create as jest.Mock).mockResolvedValue({
        id: 'assessment-integration',
        framework: 'PCI_DSS',
        siteId: mockSiteId,
        status: 'PLANNED',
        passingScore: 85,
        metadata: {},
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      (prisma.complianceRequirement.create as jest.Mock).mockResolvedValue({
        id: 'req-integration',
        requirementId: '11.2.1',
        status: 'NOT_ASSESSED',
        score: 0,
        maxScore: 3,
      });

      complianceService['mapPrismaRequirementToRequirement'] = jest.fn().mockReturnValue({
        id: 'req-integration',
        requirementId: '11.2.1',
        status: 'NOT_ASSESSED',
        score: 0,
        maxScore: 3,
      });

      const assessment = await complianceService.createComplianceAssessment({
        framework: 'PCI_DSS',
        siteId: mockSiteId,
        assessmentType: 'CONTINUOUS_MONITORING',
        scope: ['network'],
        assessor: mockUserId,
        startDate: new Date(),
        endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      });

      expect(assessment.framework).toBe('PCI_DSS');

      // Verify all components worked together
      expect(prisma.vulnerabilityScan.create).toHaveBeenCalled();
      expect(prisma.vulnerabilityRemediation.create).toHaveBeenCalled();
      expect(prisma.complianceAssessment.create).toHaveBeenCalled();
      expect(vulnerabilityService['updateVulnerabilityStatus']).toHaveBeenCalledWith(mockVulnId, 'IN_REMEDIATION');
    });
  });
});

// Helper functions for test setup
function createMockVulnerabilityScan(overrides: any = {}) {
  return {
    id: 'SCAN-TEST-123',
    scanType: 'NETWORK',
    target: '192.168.1.0/24',
    scope: ['192.168.1.1'],
    status: 'SCHEDULED',
    priority: 'NORMAL',
    scanEngine: 'nmap',
    siteId: 'test-site',
    vulnerabilitiesFound: 0,
    criticalCount: 0,
    highCount: 0,
    mediumCount: 0,
    lowCount: 0,
    infoCount: 0,
    compliance: [],
    results: [],
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
}

function createMockVulnerabilityFinding(overrides: any = {}) {
  return {
    id: 'vuln-test-123',
    scanId: 'SCAN-TEST-123',
    title: 'Test Vulnerability',
    description: 'Test vulnerability description',
    severity: 'MEDIUM',
    cvssScore: 6.0,
    riskScore: 6.0,
    affectedAssets: ['test-asset'],
    exploitAvailable: false,
    patchAvailable: true,
    firstDetected: new Date(),
    lastSeen: new Date(),
    status: 'NEW',
    references: [],
    complianceImpact: [],
    businessImpact: 'Low impact',
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
}

function createMockRemediationPlan(overrides: any = {}) {
  return {
    id: 'remediation-test-123',
    vulnerabilityId: 'vuln-test-123',
    strategy: 'PATCH',
    description: 'Test remediation plan',
    assignedTo: 'test-user',
    status: 'PLANNED',
    priority: 'P2',
    dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    approvalRequired: false,
    approvals: [],
    testingRequired: true,
    implementationSteps: [],
    estimatedEffort: 8,
    riskReduction: 80,
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
}

function createMockComplianceAssessment(overrides: any = {}) {
  return {
    id: 'assessment-test-123',
    framework: 'PCI_DSS',
    siteId: 'test-site',
    assessmentType: 'SELF_ASSESSMENT',
    scope: ['network'],
    assessor: 'test-user',
    status: 'PLANNED',
    startDate: new Date(),
    endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    overallScore: 0,
    passingScore: 85,
    passed: false,
    requirements: [],
    findings: [],
    evidence: [],
    recommendations: [],
    metadata: {},
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
} 