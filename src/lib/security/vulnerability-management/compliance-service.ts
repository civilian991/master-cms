import { prisma } from '../../prisma';
import { vulnerabilityManagementService } from './vulnerability-service';
import { z } from 'zod';

// Compliance framework definitions
const COMPLIANCE_FRAMEWORKS = {
  PCI_DSS: {
    name: 'Payment Card Industry Data Security Standard',
    version: '4.0',
    requirements: {
      '11.2.1': {
        title: 'Internal vulnerability scans',
        description: 'Perform internal vulnerability scans at least quarterly',
        category: 'VULNERABILITY_MANAGEMENT',
        priority: 'HIGH',
        frequency: 'QUARTERLY',
        evidence: ['scan_reports', 'remediation_records'],
      },
      '11.2.2': {
        title: 'External vulnerability scans',
        description: 'Perform external vulnerability scans at least quarterly',
        category: 'VULNERABILITY_MANAGEMENT',
        priority: 'HIGH',
        frequency: 'QUARTERLY',
        evidence: ['external_scan_reports', 'aqv_certification'],
      },
      '11.3.1': {
        title: 'Penetration testing',
        description: 'Perform internal and external penetration testing annually',
        category: 'PENETRATION_TESTING',
        priority: 'HIGH',
        frequency: 'ANNUALLY',
        evidence: ['pentest_reports', 'remediation_evidence'],
      },
      '6.2': {
        title: 'Security patch management',
        description: 'Ensure all systems are protected from known vulnerabilities',
        category: 'PATCH_MANAGEMENT',
        priority: 'CRITICAL',
        frequency: 'CONTINUOUS',
        evidence: ['patch_reports', 'vulnerability_assessments'],
      },
    },
    scoring: {
      weights: { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 },
      passingScore: 85,
      thresholds: { excellent: 95, good: 85, needs_improvement: 70, poor: 0 },
    },
  },

  HIPAA: {
    name: 'Health Insurance Portability and Accountability Act',
    version: '2013',
    requirements: {
      '164.308_a_5_ii_B': {
        title: 'Protection from malicious software',
        description: 'Procedures for guarding against malicious software',
        category: 'MALWARE_PROTECTION',
        priority: 'HIGH',
        frequency: 'CONTINUOUS',
        evidence: ['malware_scans', 'incident_reports'],
      },
      '164.312_b': {
        title: 'Audit controls',
        description: 'Hardware, software, and procedural mechanisms for audit logs',
        category: 'AUDIT_CONTROLS',
        priority: 'HIGH',
        frequency: 'CONTINUOUS',
        evidence: ['audit_logs', 'monitoring_reports'],
      },
    },
    scoring: {
      weights: { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 },
      passingScore: 80,
      thresholds: { excellent: 95, good: 80, needs_improvement: 65, poor: 0 },
    },
  },

  SOX: {
    name: 'Sarbanes-Oxley Act',
    version: '2002',
    requirements: {
      '302': {
        title: 'Corporate responsibility for financial reports',
        description: 'IT controls supporting financial reporting accuracy',
        category: 'IT_CONTROLS',
        priority: 'HIGH',
        frequency: 'QUARTERLY',
        evidence: ['control_assessments', 'vulnerability_reports'],
      },
      '404': {
        title: 'Assessment of internal control',
        description: 'Annual assessment of internal control effectiveness',
        category: 'INTERNAL_CONTROLS',
        priority: 'HIGH',
        frequency: 'ANNUALLY',
        evidence: ['control_testing', 'deficiency_reports'],
      },
    },
    scoring: {
      weights: { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 },
      passingScore: 90,
      thresholds: { excellent: 98, good: 90, needs_improvement: 80, poor: 0 },
    },
  },

  NIST_CSF: {
    name: 'NIST Cybersecurity Framework',
    version: '1.1',
    requirements: {
      'DE_CM_8': {
        title: 'Vulnerability scans',
        description: 'Vulnerability scans are performed',
        category: 'DETECT',
        priority: 'HIGH',
        frequency: 'CONTINUOUS',
        evidence: ['scan_schedules', 'scan_results', 'remediation_tracking'],
      },
      'RS_MI_3': {
        title: 'Vulnerability mitigation',
        description: 'Newly identified vulnerabilities are mitigated',
        category: 'RESPOND',
        priority: 'HIGH',
        frequency: 'CONTINUOUS',
        evidence: ['remediation_timelines', 'patch_management'],
      },
    },
    scoring: {
      weights: { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 },
      passingScore: 75,
      thresholds: { excellent: 90, good: 75, needs_improvement: 60, poor: 0 },
    },
  },

  ISO_27001: {
    name: 'ISO/IEC 27001:2013',
    version: '2013',
    requirements: {
      'A_12_6_1': {
        title: 'Management of technical vulnerabilities',
        description: 'Information about technical vulnerabilities shall be obtained',
        category: 'VULNERABILITY_MANAGEMENT',
        priority: 'HIGH',
        frequency: 'CONTINUOUS',
        evidence: ['vulnerability_assessments', 'patch_management'],
      },
      'A_12_6_2': {
        title: 'Restrictions on software installation',
        description: 'Rules governing installation of software shall be established',
        category: 'SOFTWARE_MANAGEMENT',
        priority: 'MEDIUM',
        frequency: 'CONTINUOUS',
        evidence: ['software_policies', 'installation_logs'],
      },
    },
    scoring: {
      weights: { CRITICAL: 4, HIGH: 3, MEDIUM: 2, LOW: 1 },
      passingScore: 80,
      thresholds: { excellent: 95, good: 80, needs_improvement: 65, poor: 0 },
    },
  },
} as const;

// Validation schemas
export const complianceAssessmentSchema = z.object({
  framework: z.enum(['PCI_DSS', 'HIPAA', 'SOX', 'NIST_CSF', 'ISO_27001']),
  siteId: z.string(),
  assessmentType: z.enum(['SELF_ASSESSMENT', 'EXTERNAL_AUDIT', 'CONTINUOUS_MONITORING']),
  scope: z.array(z.string()),
  assessor: z.string(),
  startDate: z.date(),
  endDate: z.date(),
  requirements: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
});

export const complianceEvidenceSchema = z.object({
  assessmentId: z.string(),
  requirementId: z.string(),
  evidenceType: z.enum(['DOCUMENT', 'SCAN_RESULT', 'LOG_FILE', 'SCREENSHOT', 'CERTIFICATE', 'REPORT']),
  fileName: z.string(),
  filePath: z.string(),
  description: z.string(),
  collectedBy: z.string(),
  hash: z.string(),
  metadata: z.record(z.any()).optional(),
});

export const complianceReportSchema = z.object({
  framework: z.enum(['PCI_DSS', 'HIPAA', 'SOX', 'NIST_CSF', 'ISO_27001']),
  siteId: z.string(),
  reportType: z.enum(['SUMMARY', 'DETAILED', 'EXECUTIVE', 'TECHNICAL']),
  timeRange: z.object({
    start: z.date(),
    end: z.date(),
  }),
  includeRemediation: z.boolean().default(true),
  includeEvidence: z.boolean().default(false),
  format: z.enum(['PDF', 'HTML', 'JSON', 'CSV']).default('PDF'),
});

// Interfaces
interface ComplianceAssessment {
  id: string;
  framework: string;
  siteId: string;
  assessmentType: string;
  scope: string[];
  assessor: string;
  status: 'PLANNED' | 'IN_PROGRESS' | 'COMPLETED' | 'FAILED';
  startDate: Date;
  endDate: Date;
  completedDate?: Date;
  requirements: ComplianceRequirement[];
  overallScore: number;
  passingScore: number;
  passed: boolean;
  findings: ComplianceFinding[];
  evidence: ComplianceEvidence[];
  recommendations: string[];
  metadata: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

interface ComplianceRequirement {
  id: string;
  assessmentId: string;
  requirementId: string;
  title: string;
  description: string;
  category: string;
  priority: string;
  status: 'NOT_ASSESSED' | 'COMPLIANT' | 'NON_COMPLIANT' | 'PARTIALLY_COMPLIANT' | 'NOT_APPLICABLE';
  score: number;
  maxScore: number;
  evidence: string[];
  findings: string[];
  lastAssessed: Date;
  nextAssessment: Date;
  metadata: Record<string, any>;
}

interface ComplianceFinding {
  id: string;
  assessmentId: string;
  requirementId: string;
  finding: string;
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  impact: string;
  recommendation: string;
  status: 'OPEN' | 'IN_REMEDIATION' | 'RESOLVED' | 'ACCEPTED';
  assignedTo?: string;
  dueDate?: Date;
  resolvedDate?: Date;
  evidence: string[];
  metadata: Record<string, any>;
  createdAt: Date;
}

interface ComplianceEvidence {
  id: string;
  assessmentId: string;
  requirementId: string;
  evidenceType: string;
  fileName: string;
  filePath: string;
  description: string;
  collectedBy: string;
  collectedAt: Date;
  hash: string;
  verified: boolean;
  verifiedBy?: string;
  verifiedAt?: Date;
  metadata: Record<string, any>;
}

interface ComplianceReport {
  id: string;
  framework: string;
  siteId: string;
  reportType: string;
  timeRange: { start: Date; end: Date };
  summary: {
    overallScore: number;
    passed: boolean;
    totalRequirements: number;
    compliantRequirements: number;
    nonCompliantRequirements: number;
    criticalFindings: number;
    highFindings: number;
  };
  requirements: ComplianceRequirement[];
  findings: ComplianceFinding[];
  trends: Array<{
    date: Date;
    score: number;
    compliantCount: number;
    totalCount: number;
  }>;
  recommendations: string[];
  executiveSummary: string;
  technicalDetails: string;
  generatedAt: Date;
  generatedBy: string;
}

interface ComplianceMetrics {
  framework: string;
  currentScore: number;
  previousScore: number;
  trend: 'IMPROVING' | 'DECLINING' | 'STABLE';
  complianceRate: number;
  criticalGaps: number;
  vulnerabilityAlignment: {
    criticalVulnsCompliance: number;
    highVulnsCompliance: number;
    remediationSLAMet: number;
  };
  lastAssessment: Date;
  nextAssessment: Date;
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

// Compliance Service
export class ComplianceMonitoringService {
  private activeAssessments: Map<string, ComplianceAssessment> = new Map();
  private scheduledAssessments: Map<string, NodeJS.Timeout> = new Map();

  constructor() {
    this.initializeService();
  }

  /**
   * Initialize compliance monitoring service
   */
  private async initializeService(): Promise<void> {
    try {
      // Load active assessments
      await this.loadActiveAssessments();

      // Schedule recurring assessments
      await this.scheduleRecurringAssessments();

      // Start background monitoring
      this.startBackgroundMonitoring();

      console.log('Compliance Monitoring Service initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Compliance Monitoring Service:', error);
    }
  }

  /**
   * Create compliance assessment
   */
  async createComplianceAssessment(
    assessmentData: z.infer<typeof complianceAssessmentSchema>
  ): Promise<ComplianceAssessment> {
    try {
      const validatedData = complianceAssessmentSchema.parse(assessmentData);

      // Get framework requirements
      const framework = COMPLIANCE_FRAMEWORKS[validatedData.framework];
      if (!framework) {
        throw new Error(`Unknown compliance framework: ${validatedData.framework}`);
      }

      // Filter requirements based on scope
      const requirements = validatedData.requirements || Object.keys(framework.requirements);

      // Create assessment record
      const assessment = await prisma.complianceAssessment.create({
        data: {
          framework: validatedData.framework,
          siteId: validatedData.siteId,
          assessmentType: validatedData.assessmentType,
          scope: validatedData.scope,
          assessor: validatedData.assessor,
          status: 'PLANNED',
          startDate: validatedData.startDate,
          endDate: validatedData.endDate,
          overallScore: 0,
          passingScore: framework.scoring.passingScore,
          passed: false,
          requirements: [],
          findings: [],
          evidence: [],
          recommendations: [],
          metadata: validatedData.metadata || {},
        },
      });

      // Create requirement records
      const requirementRecords = await Promise.all(
        requirements.map(async (reqId) => {
          const req = framework.requirements[reqId as keyof typeof framework.requirements];
          if (!req) return null;

          return prisma.complianceRequirement.create({
            data: {
              assessmentId: assessment.id,
              requirementId: reqId,
              title: req.title,
              description: req.description,
              category: req.category,
              priority: req.priority,
              status: 'NOT_ASSESSED',
              score: 0,
              maxScore: framework.scoring.weights[req.priority as keyof typeof framework.scoring.weights],
              evidence: [],
              findings: [],
              lastAssessed: new Date(),
              nextAssessment: this.calculateNextAssessment(req.frequency),
              metadata: {},
            },
          });
        })
      );

      const assessmentObj: ComplianceAssessment = {
        id: assessment.id,
        framework: assessment.framework,
        siteId: assessment.siteId,
        assessmentType: assessment.assessmentType,
        scope: assessment.scope as string[],
        assessor: assessment.assessor,
        status: assessment.status as any,
        startDate: assessment.startDate,
        endDate: assessment.endDate,
        requirements: requirementRecords.filter(Boolean).map(this.mapPrismaRequirementToRequirement.bind(this)),
        overallScore: assessment.overallScore,
        passingScore: assessment.passingScore,
        passed: assessment.passed,
        findings: [],
        evidence: [],
        recommendations: [],
        metadata: assessment.metadata as Record<string, any>,
        createdAt: assessment.createdAt,
        updatedAt: assessment.updatedAt,
      };

      this.activeAssessments.set(assessment.id, assessmentObj);

      return assessmentObj;

    } catch (error) {
      console.error('Failed to create compliance assessment:', error);
      throw new Error(`Assessment creation failed: ${error.message}`);
    }
  }

  /**
   * Conduct automated compliance assessment
   */
  async conductComplianceAssessment(assessmentId: string): Promise<ComplianceAssessment> {
    try {
      const assessment = this.activeAssessments.get(assessmentId);
      if (!assessment) {
        throw new Error('Assessment not found');
      }

      // Update status
      assessment.status = 'IN_PROGRESS';
      await this.updateAssessmentStatus(assessmentId, 'IN_PROGRESS');

      // Assess each requirement
      for (const requirement of assessment.requirements) {
        await this.assessRequirement(assessment, requirement);
      }

      // Calculate overall score
      const totalScore = assessment.requirements.reduce((sum, req) => sum + req.score, 0);
      const maxScore = assessment.requirements.reduce((sum, req) => sum + req.maxScore, 0);
      assessment.overallScore = maxScore > 0 ? (totalScore / maxScore) * 100 : 0;
      assessment.passed = assessment.overallScore >= assessment.passingScore;

      // Generate findings and recommendations
      assessment.findings = await this.generateFindings(assessment);
      assessment.recommendations = await this.generateRecommendations(assessment);

      // Update assessment
      assessment.status = 'COMPLETED';
      assessment.completedDate = new Date();

      await this.updateAssessmentResults(assessment);

      // Generate compliance report
      await this.generateComplianceReport({
        framework: assessment.framework as any,
        siteId: assessment.siteId,
        reportType: 'SUMMARY',
        timeRange: {
          start: assessment.startDate,
          end: assessment.endDate,
        },
      });

      return assessment;

    } catch (error) {
      console.error('Failed to conduct compliance assessment:', error);

      // Update status to failed
      if (assessment) {
        assessment.status = 'FAILED';
        await this.updateAssessmentStatus(assessmentId, 'FAILED');
      }

      throw new Error(`Assessment failed: ${error.message}`);
    }
  }

  /**
   * Add compliance evidence
   */
  async addComplianceEvidence(
    evidenceData: z.infer<typeof complianceEvidenceSchema>
  ): Promise<ComplianceEvidence> {
    try {
      const validatedData = complianceEvidenceSchema.parse(evidenceData);

      const evidence = await prisma.complianceEvidence.create({
        data: {
          assessmentId: validatedData.assessmentId,
          requirementId: validatedData.requirementId,
          evidenceType: validatedData.evidenceType,
          fileName: validatedData.fileName,
          filePath: validatedData.filePath,
          description: validatedData.description,
          collectedBy: validatedData.collectedBy,
          collectedAt: new Date(),
          hash: validatedData.hash,
          verified: false,
          metadata: validatedData.metadata || {},
        },
      });

      const evidenceObj: ComplianceEvidence = {
        id: evidence.id,
        assessmentId: evidence.assessmentId,
        requirementId: evidence.requirementId,
        evidenceType: evidence.evidenceType,
        fileName: evidence.fileName,
        filePath: evidence.filePath,
        description: evidence.description,
        collectedBy: evidence.collectedBy,
        collectedAt: evidence.collectedAt,
        hash: evidence.hash,
        verified: evidence.verified,
        metadata: evidence.metadata as Record<string, any>,
      };

      // Update assessment evidence
      const assessment = this.activeAssessments.get(validatedData.assessmentId);
      if (assessment) {
        assessment.evidence.push(evidenceObj);
      }

      return evidenceObj;

    } catch (error) {
      console.error('Failed to add compliance evidence:', error);
      throw new Error(`Evidence addition failed: ${error.message}`);
    }
  }

  /**
   * Generate compliance report
   */
  async generateComplianceReport(
    reportData: z.infer<typeof complianceReportSchema>
  ): Promise<ComplianceReport> {
    try {
      const validatedData = complianceReportSchema.parse(reportData);

      // Get assessments for the time range
      const assessments = await this.getAssessments({
        framework: validatedData.framework,
        siteId: validatedData.siteId,
        timeRange: validatedData.timeRange,
      });

      if (assessments.length === 0) {
        throw new Error('No assessments found for the specified criteria');
      }

      // Use the most recent assessment
      const latestAssessment = assessments[0];

      // Calculate summary metrics
      const summary = {
        overallScore: latestAssessment.overallScore,
        passed: latestAssessment.passed,
        totalRequirements: latestAssessment.requirements.length,
        compliantRequirements: latestAssessment.requirements.filter(r => r.status === 'COMPLIANT').length,
        nonCompliantRequirements: latestAssessment.requirements.filter(r => r.status === 'NON_COMPLIANT').length,
        criticalFindings: latestAssessment.findings.filter(f => f.severity === 'CRITICAL').length,
        highFindings: latestAssessment.findings.filter(f => f.severity === 'HIGH').length,
      };

      // Calculate trends
      const trends = await this.calculateComplianceTrends(
        validatedData.framework,
        validatedData.siteId,
        validatedData.timeRange
      );

      // Generate executive summary
      const executiveSummary = this.generateExecutiveSummary(latestAssessment, summary);

      // Generate technical details
      const technicalDetails = this.generateTechnicalDetails(latestAssessment);

      const report: ComplianceReport = {
        id: crypto.randomUUID(),
        framework: validatedData.framework,
        siteId: validatedData.siteId,
        reportType: validatedData.reportType,
        timeRange: validatedData.timeRange,
        summary,
        requirements: latestAssessment.requirements,
        findings: latestAssessment.findings,
        trends,
        recommendations: latestAssessment.recommendations,
        executiveSummary,
        technicalDetails,
        generatedAt: new Date(),
        generatedBy: 'SYSTEM',
      };

      // Store report
      await this.storeComplianceReport(report);

      return report;

    } catch (error) {
      console.error('Failed to generate compliance report:', error);
      throw new Error(`Report generation failed: ${error.message}`);
    }
  }

  /**
   * Get compliance metrics
   */
  async getComplianceMetrics(
    framework: string,
    siteId: string
  ): Promise<ComplianceMetrics> {
    try {
      // Get latest assessment
      const latestAssessment = await this.getLatestAssessment(framework, siteId);
      if (!latestAssessment) {
        throw new Error('No assessments found');
      }

      // Get previous assessment for trend analysis
      const previousAssessment = await this.getPreviousAssessment(framework, siteId, latestAssessment.createdAt);

      // Calculate trend
      let trend: 'IMPROVING' | 'DECLINING' | 'STABLE' = 'STABLE';
      if (previousAssessment) {
        if (latestAssessment.overallScore > previousAssessment.overallScore) {
          trend = 'IMPROVING';
        } else if (latestAssessment.overallScore < previousAssessment.overallScore) {
          trend = 'DECLINING';
        }
      }

      // Get vulnerability alignment metrics
      const vulnerabilityAlignment = await this.calculateVulnerabilityAlignment(siteId);

      // Calculate risk level
      const riskLevel = this.calculateRiskLevel(latestAssessment);

      return {
        framework,
        currentScore: latestAssessment.overallScore,
        previousScore: previousAssessment?.overallScore || 0,
        trend,
        complianceRate: (latestAssessment.requirements.filter(r => r.status === 'COMPLIANT').length / latestAssessment.requirements.length) * 100,
        criticalGaps: latestAssessment.findings.filter(f => f.severity === 'CRITICAL' && f.status === 'OPEN').length,
        vulnerabilityAlignment,
        lastAssessment: latestAssessment.completedDate || latestAssessment.createdAt,
        nextAssessment: this.calculateNextAssessmentDate(framework, latestAssessment.completedDate || latestAssessment.createdAt),
        riskLevel,
      };

    } catch (error) {
      console.error('Failed to get compliance metrics:', error);
      throw new Error(`Metrics calculation failed: ${error.message}`);
    }
  }

  // Helper methods (private)

  private async loadActiveAssessments(): Promise<void> {
    const assessments = await prisma.complianceAssessment.findMany({
      where: { status: { in: ['PLANNED', 'IN_PROGRESS'] } },
      include: {
        requirements: true,
        findings: true,
        evidence: true,
      },
    });

    for (const assessment of assessments) {
      const assessmentObj = this.mapPrismaAssessmentToAssessment(assessment);
      this.activeAssessments.set(assessment.id, assessmentObj);
    }
  }

  private async scheduleRecurringAssessments(): Promise<void> {
    // Schedule assessments based on framework frequencies
    for (const [frameworkName, framework] of Object.entries(COMPLIANCE_FRAMEWORKS)) {
      await this.scheduleFrameworkAssessments(frameworkName, framework);
    }
  }

  private startBackgroundMonitoring(): void {
    // Monitor compliance status daily
    setInterval(async () => {
      await this.monitorComplianceStatus();
    }, 24 * 60 * 60 * 1000);

    // Check for upcoming assessment deadlines
    setInterval(async () => {
      await this.checkAssessmentDeadlines();
    }, 60 * 60 * 1000);
  }

  private async assessRequirement(
    assessment: ComplianceAssessment,
    requirement: ComplianceRequirement
  ): Promise<void> {
    // Get vulnerability data relevant to this requirement
    const vulnerabilities = await vulnerabilityManagementService.getVulnerabilityFindings({
      siteId: assessment.siteId,
    });

    // Assess based on requirement type
    switch (requirement.category) {
      case 'VULNERABILITY_MANAGEMENT':
        await this.assessVulnerabilityManagement(requirement, vulnerabilities);
        break;
      case 'PATCH_MANAGEMENT':
        await this.assessPatchManagement(requirement, vulnerabilities);
        break;
      default:
        await this.assessGenericRequirement(requirement);
    }
  }

  private async assessVulnerabilityManagement(
    requirement: ComplianceRequirement,
    vulnerabilities: any[]
  ): Promise<void> {
    // Check if vulnerability scans are being performed
    const recentScans = await this.getRecentScans(30); // Last 30 days

    if (recentScans.length === 0) {
      requirement.status = 'NON_COMPLIANT';
      requirement.score = 0;
      requirement.findings.push('No vulnerability scans performed in the last 30 days');
    } else {
      // Check critical vulnerabilities
      const criticalVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL' && v.status === 'NEW');

      if (criticalVulns.length > 0) {
        requirement.status = 'PARTIALLY_COMPLIANT';
        requirement.score = requirement.maxScore * 0.5;
        requirement.findings.push(`${criticalVulns.length} critical vulnerabilities require immediate attention`);
      } else {
        requirement.status = 'COMPLIANT';
        requirement.score = requirement.maxScore;
      }
    }
  }

  private async assessPatchManagement(
    requirement: ComplianceRequirement,
    vulnerabilities: any[]
  ): Promise<void> {
    // Check patch management effectiveness
    const vulnerabilitiesWithPatches = vulnerabilities.filter(v => v.patchAvailable);
    const unpatchedCritical = vulnerabilitiesWithPatches.filter(
      v => v.severity === 'CRITICAL' && v.status !== 'RESOLVED'
    );

    if (unpatchedCritical.length > 0) {
      requirement.status = 'NON_COMPLIANT';
      requirement.score = 0;
      requirement.findings.push(`${unpatchedCritical.length} critical vulnerabilities with available patches remain unpatched`);
    } else {
      requirement.status = 'COMPLIANT';
      requirement.score = requirement.maxScore;
    }
  }

  private async assessGenericRequirement(requirement: ComplianceRequirement): Promise<void> {
    // Default assessment for requirements without specific logic
    requirement.status = 'NOT_ASSESSED';
    requirement.score = 0;
    requirement.findings.push('Manual assessment required');
  }

  private calculateNextAssessment(frequency: string): Date {
    const now = new Date();
    switch (frequency) {
      case 'QUARTERLY': return new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000);
      case 'ANNUALLY': return new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000);
      case 'CONTINUOUS': return new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
      default: return new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
    }
  }

  private async generateFindings(assessment: ComplianceAssessment): Promise<ComplianceFinding[]> {
    const findings: ComplianceFinding[] = [];

    for (const requirement of assessment.requirements) {
      if (requirement.status === 'NON_COMPLIANT' || requirement.status === 'PARTIALLY_COMPLIANT') {
        for (const findingText of requirement.findings) {
          findings.push({
            id: crypto.randomUUID(),
            assessmentId: assessment.id,
            requirementId: requirement.requirementId,
            finding: findingText,
            severity: requirement.priority === 'CRITICAL' ? 'CRITICAL' : 'HIGH',
            impact: 'Compliance violation may result in penalties or audit findings',
            recommendation: 'Address finding to achieve compliance',
            status: 'OPEN',
            evidence: [],
            metadata: {},
            createdAt: new Date(),
          });
        }
      }
    }

    return findings;
  }

  private async generateRecommendations(assessment: ComplianceAssessment): Promise<string[]> {
    const recommendations: string[] = [];

    // Analyze findings and generate actionable recommendations
    const criticalFindings = assessment.findings.filter(f => f.severity === 'CRITICAL');
    const highFindings = assessment.findings.filter(f => f.severity === 'HIGH');

    if (criticalFindings.length > 0) {
      recommendations.push('Address all critical compliance gaps immediately to avoid regulatory violations');
    }

    if (highFindings.length > 0) {
      recommendations.push('Develop remediation plan for high-priority compliance findings');
    }

    if (assessment.overallScore < assessment.passingScore) {
      recommendations.push('Implement comprehensive compliance improvement program');
    }

    recommendations.push('Establish regular compliance monitoring and assessment schedule');
    recommendations.push('Provide compliance training to relevant personnel');

    return recommendations;
  }

  // Additional helper methods would continue here...
  private async updateAssessmentStatus(assessmentId: string, status: string): Promise<void> { /* Implementation */ }
  private async updateAssessmentResults(assessment: ComplianceAssessment): Promise<void> { /* Implementation */ }
  private async getAssessments(filters: any): Promise<ComplianceAssessment[]> { return []; }
  private async calculateComplianceTrends(framework: string, siteId: string, timeRange: any): Promise<any[]> { return []; }
  private generateExecutiveSummary(assessment: ComplianceAssessment, summary: any): string { return ''; }
  private generateTechnicalDetails(assessment: ComplianceAssessment): string { return ''; }
  private async storeComplianceReport(report: ComplianceReport): Promise<void> { /* Implementation */ }
  private async getLatestAssessment(framework: string, siteId: string): Promise<ComplianceAssessment | null> { return null; }
  private async getPreviousAssessment(framework: string, siteId: string, beforeDate: Date): Promise<ComplianceAssessment | null> { return null; }
  private async calculateVulnerabilityAlignment(siteId: string): Promise<any> { return {}; }
  private calculateRiskLevel(assessment: ComplianceAssessment): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' { return 'MEDIUM'; }
  private calculateNextAssessmentDate(framework: string, lastAssessment: Date): Date { return new Date(); }
  private mapPrismaAssessmentToAssessment(assessment: any): ComplianceAssessment { return {} as ComplianceAssessment; }
  private mapPrismaRequirementToRequirement(requirement: any): ComplianceRequirement { return {} as ComplianceRequirement; }
  private async scheduleFrameworkAssessments(frameworkName: string, framework: any): Promise<void> { /* Implementation */ }
  private async monitorComplianceStatus(): Promise<void> { /* Implementation */ }
  private async checkAssessmentDeadlines(): Promise<void> { /* Implementation */ }
  private async getRecentScans(days: number): Promise<any[]> { return []; }
}

// Export singleton instance
export const complianceMonitoringService = new ComplianceMonitoringService();

// Export types
export type {
  ComplianceAssessment,
  ComplianceRequirement,
  ComplianceFinding,
  ComplianceEvidence,
  ComplianceReport,
  ComplianceMetrics,
}; 