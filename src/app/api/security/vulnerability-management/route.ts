import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth/nextauth';
import { vulnerabilityManagementService } from '@/lib/security/vulnerability-management/vulnerability-service';
import { complianceMonitoringService } from '@/lib/security/vulnerability-management/compliance-service';
import { z } from 'zod';

const vulnerabilityScanSchema = z.object({
  scanType: z.enum(['NETWORK', 'WEB_APPLICATION', 'DATABASE', 'CONTAINER', 'INFRASTRUCTURE', 'CODE']),
  target: z.string(),
  scope: z.array(z.string()),
  scheduledTime: z.string().optional(),
  priority: z.enum(['LOW', 'NORMAL', 'HIGH', 'URGENT']).default('NORMAL'),
  options: z.record(z.any()).optional(),
  compliance: z.array(z.string()).optional(),
});

const vulnerabilityRemediationSchema = z.object({
  vulnerabilityId: z.string(),
  strategy: z.enum(['PATCH', 'CONFIGURATION', 'MITIGATION', 'ISOLATION', 'UPGRADE']),
  assignedTo: z.string(),
  dueDate: z.string(),
  priority: z.enum(['P1', 'P2', 'P3', 'P4']),
  approvalRequired: z.boolean().default(false),
  testingRequired: z.boolean().default(true),
  maintenanceWindow: z.string().optional(),
  rollbackPlan: z.string().optional(),
  metadata: z.record(z.any()).optional(),
});

const patchDeploymentSchema = z.object({
  patchId: z.string(),
  targetSystems: z.array(z.string()),
  deploymentPhase: z.enum(['DEV', 'STAGING', 'PRODUCTION']),
  scheduledTime: z.string(),
  approvals: z.array(z.object({
    approver: z.string(),
    approved: z.boolean(),
    timestamp: z.string(),
    comments: z.string().optional(),
  })),
  rollbackPlan: z.string(),
  testingCriteria: z.array(z.string()),
  metadata: z.record(z.any()).optional(),
});

const complianceAssessmentSchema = z.object({
  framework: z.enum(['PCI_DSS', 'HIPAA', 'SOX', 'NIST_CSF', 'ISO_27001']),
  assessmentType: z.enum(['SELF_ASSESSMENT', 'EXTERNAL_AUDIT', 'CONTINUOUS_MONITORING']),
  scope: z.array(z.string()),
  assessor: z.string(),
  startDate: z.string(),
  endDate: z.string(),
  requirements: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
});

const complianceEvidenceSchema = z.object({
  assessmentId: z.string(),
  requirementId: z.string(),
  evidenceType: z.enum(['DOCUMENT', 'SCAN_RESULT', 'LOG_FILE', 'SCREENSHOT', 'CERTIFICATE', 'REPORT']),
  fileName: z.string(),
  filePath: z.string(),
  description: z.string(),
  hash: z.string(),
  metadata: z.record(z.any()).optional(),
});

const vulnerabilityUpdateSchema = z.object({
  vulnerabilityId: z.string(),
  status: z.enum(['NEW', 'CONFIRMED', 'IN_REMEDIATION', 'RESOLVED', 'ACCEPTED_RISK', 'FALSE_POSITIVE']).optional(),
  assignedTo: z.string().optional(),
  dueDate: z.string().optional(),
  businessImpact: z.string().optional(),
  notes: z.string().optional(),
  metadata: z.record(z.any()).optional(),
});

export async function POST(request: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Check vulnerability management permissions
    if (!session.user.permissions?.includes('manage_vulnerabilities')) {
      return NextResponse.json(
        { error: 'Insufficient permissions for vulnerability management' },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { action } = body;

    // Get request metadata
    const userAgent = request.headers.get('user-agent') || '';
    const xForwardedFor = request.headers.get('x-forwarded-for');
    const xRealIp = request.headers.get('x-real-ip');
    const ipAddress = xForwardedFor?.split(',')[0] || xRealIp || 'unknown';

    if (action === 'schedule-scan') {
      // Schedule vulnerability scan
      const validatedData = vulnerabilityScanSchema.parse(body);

      const scan = await vulnerabilityManagementService.scheduleVulnerabilityScan({
        scanType: validatedData.scanType,
        target: validatedData.target,
        scope: validatedData.scope,
        scheduledTime: validatedData.scheduledTime ? new Date(validatedData.scheduledTime) : undefined,
        priority: validatedData.priority,
        options: validatedData.options,
        compliance: validatedData.compliance,
        siteId: session.user.siteId!,
      });

      return NextResponse.json({
        success: true,
        scan,
        message: `${validatedData.scanType} scan scheduled successfully`,
      });

    } else if (action === 'create-remediation') {
      // Create vulnerability remediation plan
      const validatedData = vulnerabilityRemediationSchema.parse(body);

      const remediation = await vulnerabilityManagementService.createRemediationPlan({
        vulnerabilityId: validatedData.vulnerabilityId,
        strategy: validatedData.strategy,
        assignedTo: validatedData.assignedTo,
        dueDate: new Date(validatedData.dueDate),
        priority: validatedData.priority,
        approvalRequired: validatedData.approvalRequired,
        testingRequired: validatedData.testingRequired,
        maintenanceWindow: validatedData.maintenanceWindow,
        rollbackPlan: validatedData.rollbackPlan,
        metadata: validatedData.metadata,
      });

      return NextResponse.json({
        success: true,
        remediation,
        message: 'Remediation plan created successfully',
      });

    } else if (action === 'deploy-patch') {
      // Deploy security patch
      const validatedData = patchDeploymentSchema.parse(body);

      const deployment = await vulnerabilityManagementService.deployPatch({
        patchId: validatedData.patchId,
        targetSystems: validatedData.targetSystems,
        deploymentPhase: validatedData.deploymentPhase,
        scheduledTime: new Date(validatedData.scheduledTime),
        approvals: validatedData.approvals.map(a => ({
          ...a,
          timestamp: new Date(a.timestamp),
        })),
        rollbackPlan: validatedData.rollbackPlan,
        testingCriteria: validatedData.testingCriteria,
        metadata: validatedData.metadata,
      });

      return NextResponse.json({
        success: true,
        deployment,
        message: 'Patch deployment initiated successfully',
      });

    } else if (action === 'update-vulnerability') {
      // Update vulnerability status and details
      const validatedData = vulnerabilityUpdateSchema.parse(body);

      // Implementation would update vulnerability in database
      // For now, return success response
      return NextResponse.json({
        success: true,
        message: 'Vulnerability updated successfully',
        vulnerabilityId: validatedData.vulnerabilityId,
        updates: {
          status: validatedData.status,
          assignedTo: validatedData.assignedTo,
          dueDate: validatedData.dueDate,
          updatedBy: session.user.id,
          updatedAt: new Date().toISOString(),
        },
      });

    } else if (action === 'bulk-remediation') {
      // Bulk remediation assignment
      const { vulnerabilityIds, strategy, assignedTo, dueDate, priority } = body;

      if (!vulnerabilityIds || !Array.isArray(vulnerabilityIds) || vulnerabilityIds.length === 0) {
        return NextResponse.json(
          { error: 'Vulnerability IDs array is required' },
          { status: 400 }
        );
      }

      const results = [];

      for (const vulnerabilityId of vulnerabilityIds) {
        try {
          const remediation = await vulnerabilityManagementService.createRemediationPlan({
            vulnerabilityId,
            strategy: strategy || 'PATCH',
            assignedTo: assignedTo || session.user.id,
            dueDate: new Date(dueDate || Date.now() + 7 * 24 * 60 * 60 * 1000), // Default 7 days
            priority: priority || 'P3',
            approvalRequired: false,
            testingRequired: true,
          });
          results.push({ vulnerabilityId, success: true, remediation });
        } catch (error) {
          results.push({ vulnerabilityId, success: false, error: error.message });
        }
      }

      return NextResponse.json({
        success: true,
        results,
        message: `Bulk remediation completed. ${results.filter(r => r.success).length}/${vulnerabilityIds.length} plans created successfully`,
      });

    } else if (action === 'create-compliance-assessment') {
      // Create compliance assessment
      const validatedData = complianceAssessmentSchema.parse(body);

      const assessment = await complianceMonitoringService.createComplianceAssessment({
        framework: validatedData.framework,
        siteId: session.user.siteId!,
        assessmentType: validatedData.assessmentType,
        scope: validatedData.scope,
        assessor: validatedData.assessor,
        startDate: new Date(validatedData.startDate),
        endDate: new Date(validatedData.endDate),
        requirements: validatedData.requirements,
        metadata: validatedData.metadata,
      });

      return NextResponse.json({
        success: true,
        assessment,
        message: 'Compliance assessment created successfully',
      });

    } else if (action === 'conduct-compliance-assessment') {
      // Conduct automated compliance assessment
      const { assessmentId } = body;

      if (!assessmentId) {
        return NextResponse.json(
          { error: 'Assessment ID is required' },
          { status: 400 }
        );
      }

      const assessment = await complianceMonitoringService.conductComplianceAssessment(assessmentId);

      return NextResponse.json({
        success: true,
        assessment,
        message: 'Compliance assessment completed successfully',
      });

    } else if (action === 'add-compliance-evidence') {
      // Add compliance evidence
      const validatedData = complianceEvidenceSchema.parse(body);

      const evidence = await complianceMonitoringService.addComplianceEvidence({
        assessmentId: validatedData.assessmentId,
        requirementId: validatedData.requirementId,
        evidenceType: validatedData.evidenceType,
        fileName: validatedData.fileName,
        filePath: validatedData.filePath,
        description: validatedData.description,
        collectedBy: session.user.id,
        hash: validatedData.hash,
        metadata: validatedData.metadata,
      });

      return NextResponse.json({
        success: true,
        evidence,
        message: 'Compliance evidence added successfully',
      });

    } else if (action === 'execute-scan') {
      // Execute immediate vulnerability scan
      const { scanId } = body;

      if (!scanId) {
        return NextResponse.json(
          { error: 'Scan ID is required' },
          { status: 400 }
        );
      }

      // Implementation would trigger scan execution
      return NextResponse.json({
        success: true,
        message: 'Vulnerability scan execution initiated',
        scanId,
        status: 'RUNNING',
        startedAt: new Date().toISOString(),
      });

    } else if (action === 'approve-remediation') {
      // Approve remediation plan
      const { remediationId, approved, comments } = body;

      if (!remediationId || approved === undefined) {
        return NextResponse.json(
          { error: 'Remediation ID and approval status are required' },
          { status: 400 }
        );
      }

      // Implementation would update remediation approval
      return NextResponse.json({
        success: true,
        message: `Remediation plan ${approved ? 'approved' : 'rejected'} successfully`,
        remediationId,
        approval: {
          approver: session.user.id,
          approved,
          timestamp: new Date().toISOString(),
          comments,
        },
      });

    } else if (action === 'risk-accept') {
      // Accept vulnerability risk
      const { vulnerabilityId, justification, approver, expiryDate } = body;

      if (!vulnerabilityId || !justification) {
        return NextResponse.json(
          { error: 'Vulnerability ID and justification are required' },
          { status: 400 }
        );
      }

      // Implementation would update vulnerability to accepted risk status
      return NextResponse.json({
        success: true,
        message: 'Vulnerability risk accepted successfully',
        vulnerabilityId,
        riskAcceptance: {
          acceptedBy: session.user.id,
          justification,
          approver,
          expiryDate,
          acceptedAt: new Date().toISOString(),
        },
      });

    } else {
      return NextResponse.json(
        { error: 'Invalid action. Supported actions: schedule-scan, create-remediation, deploy-patch, update-vulnerability, bulk-remediation, create-compliance-assessment, conduct-compliance-assessment, add-compliance-evidence, execute-scan, approve-remediation, risk-accept' },
        { status: 400 }
      );
    }

  } catch (error) {
    console.error('Vulnerability management API error:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Vulnerability management operation failed', details: error.message },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Check view permissions
    if (!session.user.permissions?.includes('view_vulnerabilities')) {
      return NextResponse.json(
        { error: 'Insufficient permissions to view vulnerabilities' },
        { status: 403 }
      );
    }

    const url = new URL(request.url);
    const action = url.searchParams.get('action') || 'list-vulnerabilities';

    if (action === 'list-vulnerabilities') {
      // Get vulnerabilities with filtering
      const severity = url.searchParams.get('severity');
      const status = url.searchParams.get('status');
      const assignedTo = url.searchParams.get('assignedTo');
      const compliance = url.searchParams.get('compliance');
      const limit = parseInt(url.searchParams.get('limit') || '50');

      const filters: any = {
        siteId: session.user.siteId,
        limit,
      };

      if (severity) filters.severity = severity;
      if (status) filters.status = status;
      if (assignedTo) filters.assignedTo = assignedTo;
      if (compliance) filters.compliance = compliance;

      const vulnerabilities = await vulnerabilityManagementService.getVulnerabilityFindings(filters);

      return NextResponse.json({
        success: true,
        vulnerabilities,
        totalCount: vulnerabilities.length,
      });

    } else if (action === 'vulnerability-metrics') {
      // Get vulnerability metrics and dashboard data
      const timeRange = url.searchParams.get('timeRange') || '30d';
      const startDate = url.searchParams.get('startDate');
      const endDate = url.searchParams.get('endDate');

      let dateRange: { start: Date; end: Date } | undefined;

      if (startDate && endDate) {
        dateRange = {
          start: new Date(startDate),
          end: new Date(endDate),
        };
      } else {
        const end = new Date();
        let start: Date;

        switch (timeRange) {
          case '7d':
            start = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
            break;
          case '30d':
            start = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            break;
          case '90d':
            start = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
            break;
          case '1y':
            start = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000);
            break;
          default:
            start = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        }

        dateRange = { start, end };
      }

      const metrics = await vulnerabilityManagementService.getVulnerabilityMetrics(
        session.user.siteId!,
        dateRange
      );

      return NextResponse.json({
        success: true,
        metrics,
        timeRange: dateRange,
      });

    } else if (action === 'scan-history') {
      // Get vulnerability scan history
      const scanType = url.searchParams.get('scanType');
      const status = url.searchParams.get('status');
      const limit = parseInt(url.searchParams.get('limit') || '20');

      // Implementation would query scan history from database
      const scans = []; // Mock data

      return NextResponse.json({
        success: true,
        scans,
        totalCount: scans.length,
      });

    } else if (action === 'compliance-dashboard') {
      // Get compliance dashboard data
      const framework = url.searchParams.get('framework');

      if (!framework) {
        return NextResponse.json(
          { error: 'Framework parameter is required' },
          { status: 400 }
        );
      }

      const metrics = await complianceMonitoringService.getComplianceMetrics(
        framework,
        session.user.siteId!
      );

      return NextResponse.json({
        success: true,
        compliance: metrics,
      });

    } else if (action === 'compliance-report') {
      // Generate compliance report
      const framework = url.searchParams.get('framework');
      const reportType = url.searchParams.get('reportType') || 'SUMMARY';
      const startDate = url.searchParams.get('startDate');
      const endDate = url.searchParams.get('endDate');
      const format = url.searchParams.get('format') || 'PDF';

      if (!framework || !startDate || !endDate) {
        return NextResponse.json(
          { error: 'Framework, start date, and end date are required' },
          { status: 400 }
        );
      }

      const report = await complianceMonitoringService.generateComplianceReport({
        framework: framework as any,
        siteId: session.user.siteId!,
        reportType: reportType as any,
        timeRange: {
          start: new Date(startDate),
          end: new Date(endDate),
        },
        includeRemediation: true,
        includeEvidence: reportType === 'DETAILED',
        format: format as any,
      });

      return NextResponse.json({
        success: true,
        report,
      });

    } else if (action === 'remediation-dashboard') {
      // Get remediation dashboard data
      const assignedTo = url.searchParams.get('assignedTo');
      const priority = url.searchParams.get('priority');
      const status = url.searchParams.get('status');

      // Implementation would query remediation data
      const dashboard = {
        summary: {
          total: 0,
          inProgress: 0,
          overdue: 0,
          completed: 0,
        },
        byPriority: { P1: 0, P2: 0, P3: 0, P4: 0 },
        byStrategy: { PATCH: 0, CONFIGURATION: 0, MITIGATION: 0, ISOLATION: 0, UPGRADE: 0 },
        recentActions: [],
        upcomingDeadlines: [],
      };

      return NextResponse.json({
        success: true,
        dashboard,
      });

    } else if (action === 'patch-dashboard') {
      // Get patch management dashboard data
      const phase = url.searchParams.get('phase');
      const status = url.searchParams.get('status');

      const dashboard = {
        summary: {
          totalPatches: 0,
          pendingApproval: 0,
          inTesting: 0,
          readyForProduction: 0,
          deployed: 0,
          failed: 0,
        },
        byPhase: { DEV: 0, STAGING: 0, PRODUCTION: 0 },
        bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 },
        recentDeployments: [],
        upcomingDeployments: [],
        rollbacks: [],
      };

      return NextResponse.json({
        success: true,
        dashboard,
      });

    } else if (action === 'vulnerability-report') {
      // Generate vulnerability report
      const reportType = url.searchParams.get('reportType') || 'SUMMARY';
      const severity = url.searchParams.get('severity');
      const status = url.searchParams.get('status');
      const startDate = url.searchParams.get('startDate');
      const endDate = url.searchParams.get('endDate');
      const format = url.searchParams.get('format') || 'PDF';

      const filters: any = { siteId: session.user.siteId };
      if (severity) filters.severity = severity;
      if (status) filters.status = status;

      if (startDate && endDate) {
        filters.timeRange = {
          start: new Date(startDate),
          end: new Date(endDate),
        };
      }

      // Implementation would generate detailed vulnerability report
      const report = {
        id: crypto.randomUUID(),
        type: reportType,
        filters,
        summary: {
          totalVulnerabilities: 0,
          bySeverity: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0, INFORMATIONAL: 0 },
          byStatus: { NEW: 0, CONFIRMED: 0, IN_REMEDIATION: 0, RESOLVED: 0 },
          meanTimeToRemediation: 0,
          slaCompliance: 0,
        },
        vulnerabilities: [],
        trends: [],
        recommendations: [],
        generatedAt: new Date().toISOString(),
        generatedBy: session.user.id,
      };

      return NextResponse.json({
        success: true,
        report,
      });

    } else if (action === 'scan-templates') {
      // Get vulnerability scan templates and configurations
      const templates = {
        scanTypes: [
          { value: 'NETWORK', label: 'Network Vulnerability Scan', description: 'Scan network infrastructure for vulnerabilities' },
          { value: 'WEB_APPLICATION', label: 'Web Application Security Scan', description: 'Scan web applications for security issues' },
          { value: 'DATABASE', label: 'Database Security Assessment', description: 'Assess database security configuration' },
          { value: 'CONTAINER', label: 'Container Image Scan', description: 'Scan container images for vulnerabilities' },
          { value: 'INFRASTRUCTURE', label: 'Infrastructure Scan', description: 'Scan server and infrastructure components' },
          { value: 'CODE', label: 'Static Code Analysis', description: 'Analyze source code for security vulnerabilities' },
        ],
        priorities: [
          { value: 'LOW', label: 'Low Priority' },
          { value: 'NORMAL', label: 'Normal Priority' },
          { value: 'HIGH', label: 'High Priority' },
          { value: 'URGENT', label: 'Urgent Priority' },
        ],
        complianceFrameworks: [
          { value: 'PCI_DSS', label: 'PCI DSS' },
          { value: 'HIPAA', label: 'HIPAA' },
          { value: 'SOX', label: 'SOX' },
          { value: 'NIST_CSF', label: 'NIST Cybersecurity Framework' },
          { value: 'ISO_27001', label: 'ISO 27001' },
        ],
        remediationStrategies: [
          { value: 'PATCH', label: 'Apply Security Patch' },
          { value: 'CONFIGURATION', label: 'Configuration Change' },
          { value: 'MITIGATION', label: 'Implement Mitigation Controls' },
          { value: 'ISOLATION', label: 'Isolate Affected System' },
          { value: 'UPGRADE', label: 'Software/Hardware Upgrade' },
        ],
        severityLevels: [
          { value: 'CRITICAL', label: 'Critical', color: '#FF0000', score: [9.0, 10.0] },
          { value: 'HIGH', label: 'High', color: '#FF6600', score: [7.0, 8.9] },
          { value: 'MEDIUM', label: 'Medium', color: '#FFAA00', score: [4.0, 6.9] },
          { value: 'LOW', label: 'Low', color: '#00AA00', score: [0.1, 3.9] },
          { value: 'INFORMATIONAL', label: 'Informational', color: '#0066CC', score: [0.0, 0.0] },
        ],
      };

      return NextResponse.json({
        success: true,
        templates,
      });

    } else {
      return NextResponse.json(
        { error: 'Invalid action' },
        { status: 400 }
      );
    }

  } catch (error) {
    console.error('Vulnerability management GET error:', error);
    return NextResponse.json(
      { error: 'Failed to get vulnerability management data' },
      { status: 500 }
    );
  }
}

export async function PUT(request: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Check update permissions
    if (!session.user.permissions?.includes('manage_vulnerabilities')) {
      return NextResponse.json(
        { error: 'Insufficient permissions for vulnerability updates' },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { action } = body;

    if (action === 'update-scan-status') {
      // Update scan status
      const { scanId, status, results } = body;

      if (!scanId || !status) {
        return NextResponse.json(
          { error: 'Scan ID and status are required' },
          { status: 400 }
        );
      }

      // Implementation would update scan in database
      return NextResponse.json({
        success: true,
        message: 'Scan status updated successfully',
        scanId,
        status,
        updatedAt: new Date().toISOString(),
      });

    } else if (action === 'update-remediation-progress') {
      // Update remediation progress
      const { remediationId, progress, status, notes } = body;

      if (!remediationId) {
        return NextResponse.json(
          { error: 'Remediation ID is required' },
          { status: 400 }
        );
      }

      // Implementation would update remediation progress
      return NextResponse.json({
        success: true,
        message: 'Remediation progress updated successfully',
        remediationId,
        progress,
        status,
        updatedBy: session.user.id,
        updatedAt: new Date().toISOString(),
      });

    } else if (action === 'update-compliance-finding') {
      // Update compliance finding status
      const { findingId, status, resolution, assignedTo } = body;

      if (!findingId || !status) {
        return NextResponse.json(
          { error: 'Finding ID and status are required' },
          { status: 400 }
        );
      }

      // Implementation would update compliance finding
      return NextResponse.json({
        success: true,
        message: 'Compliance finding updated successfully',
        findingId,
        status,
        updatedBy: session.user.id,
        updatedAt: new Date().toISOString(),
      });

    } else {
      return NextResponse.json(
        { error: 'Invalid action' },
        { status: 400 }
      );
    }

  } catch (error) {
    console.error('Vulnerability management PUT error:', error);
    return NextResponse.json(
      { error: 'Failed to update vulnerability management data' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    // Check authentication
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Check delete permissions
    if (!session.user.permissions?.includes('manage_vulnerabilities')) {
      return NextResponse.json(
        { error: 'Insufficient permissions for vulnerability deletion' },
        { status: 403 }
      );
    }

    const url = new URL(request.url);
    const action = url.searchParams.get('action');

    if (action === 'cancel-scan') {
      // Cancel scheduled scan
      const scanId = url.searchParams.get('scanId');

      if (!scanId) {
        return NextResponse.json(
          { error: 'Scan ID is required' },
          { status: 400 }
        );
      }

      // Implementation would cancel scan
      return NextResponse.json({
        success: true,
        message: 'Scan cancelled successfully',
        scanId,
        cancelledBy: session.user.id,
        cancelledAt: new Date().toISOString(),
      });

    } else if (action === 'remove-false-positive') {
      // Remove false positive vulnerability
      const vulnerabilityId = url.searchParams.get('vulnerabilityId');

      if (!vulnerabilityId) {
        return NextResponse.json(
          { error: 'Vulnerability ID is required' },
          { status: 400 }
        );
      }

      // Implementation would mark as false positive and remove
      return NextResponse.json({
        success: true,
        message: 'Vulnerability marked as false positive and removed',
        vulnerabilityId,
        removedBy: session.user.id,
        removedAt: new Date().toISOString(),
      });

    } else {
      return NextResponse.json(
        { error: 'Invalid action' },
        { status: 400 }
      );
    }

  } catch (error) {
    console.error('Vulnerability management DELETE error:', error);
    return NextResponse.json(
      { error: 'Failed to delete vulnerability management data' },
      { status: 500 }
    );
  }
} 